SET SERVEROUTPUT ON

CREATE OR REPLACE PROCEDURE MY_PARAMETER_TEST_PROC
(P_VAR1 VARCHAR2, P_VAR2 OUT VARCHAR2, P_VAR3 IN OUT VARCHAR2)
IS BEGIN DBMS_OUTPUT.PUT_LINE('P_VAR1 VALUE='||P_VAR1);
DBMS_OUTPUT.PUT_LINE('P_VAR2 VALUE='||P_VAR2);
DBMS_OUTPUT.PUT_LINE('P_VAR3 VALUE='||P_VAR3);

P_VAR2:='B2'; P_VAR3:='C2';
DBMS_OUTPUT.PUT_LINE('P_VAR1 VALUE='||P_VAR1);
DBMS_OUTPUT.PUT_LINE('P_VAR2 VALUE='||P_VAR2);
DBMS_OUTPUT.PUT_LINE('P_VAR3 VALUE='||P_VAR3); END;
/


DECLARE
V_VAR1 VARCHAR2(10):='A';
V_VAR2 VARCHAR2(10):='B';
V_VAR3 VARCHAR2(10):='C';
BEGIN
DBMS_OUTPUT.PUT_LINE('V_VAR1 VALUE=' ||V_VAR1);
DBMS_OUTPUT.PUT_LINE('V_VAR2 VALUE=' ||V_VAR2);
DBMS_OUTPUT.PUT_LINE('V_VAR3 VALUE=' ||V_VAR3);
DBMS_OUTPUT.PUT_LINE('==============================');

MY_PARAMETER_TEST_PROC(V_VAR1,V_VAR2,V_VAR3);
DBMS_OUTPUT.PUT_LINE('==============================');

DBMS_OUTPUT.PUT_LINE('V_VAR1 VALUE=' ||V_VAR1);
DBMS_OUTPUT.PUT_LINE('V_VAR2 VALUE=' ||V_VAR2);
DBMS_OUTPUT.PUT_LINE('V_VAR3 VALUE=' ||V_VAR3);
END;
/



CREATE OR REPLACE PROCEDURE MY_NEW_JOB_PROC
(P_JOB_ID IN JOBS.JOB_ID%TYPE,
 P_JOB_TITLE IN JOBS.JOB_TITLE%TYPE,
 P_MIN_SAL IN JOBS.MIN_SALARY%TYPE:=10,
 P_MAX_SAL IN JOBS.MAX_SALARY%TYPE:=100)
IS VN_CNT NUMBER:=0;
BEGIN IF P_MIN_SAL<1000 THEN
DBMS_OUTPUT.PUT_LINE('최소 급여값은 1000 이상이어야 한다.');
RETURN; --실행문 완전 종료
END IF;

SELECT COUNT(*) INTO VN_CNT FROM JOBS WHERE JOB_ID=P_JOB_ID;

IF VN_CNT>0 THEN UPDATE JOBS
SET JOB_TITLE=P_JOB_TITLE,MIN_SALARY=P_MIN_SAL,
MAX_SALARY=P_MAX_SAL,UPDATE_DATE=SYSDATE WHERE JOB_ID=P_JOB_ID;
DBMS_OUTPUT.PUT_LINE('데이터 갱신완료');

ELSE INSERT INTO JOBS(JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY,
CREATE_DATE,UPDATE_DATE)
VALUES(P_JOB_ID,P_JOB_TITLE,P_MIN_SAL,P_MAX_SAL,SYSDATE,SYSDATE);
DBMS_OUTPUT.PUT_LINE('데이터 추가완료');
END IF; COMMIT; END;
/


EXEC MY_NEW_JOB_PROC('SM_JOB1','SAMPLE JOB1',2000,6000);




DECLARE V_DEPTNO EMP.DEPTNO%TYPE:=30; V_EMP EMP%ROWTYPE;
BEGIN --묵시적 커서: 여러행의 데이터가 자동으로(묵시적으로) 처리됨.
UPDATE EMP01 SET SAL=SAL+SAL*0.01 WHERE DEPTNO=V_DEPTNO;

DBMS_OUTPUT.PUT_LINE(SQL%ROWCOUNT);
--SQL%ROWCOUNT:커서명이 없을 경우 바로 전에 실행된 SQL문의 ROW수 반환하는 커서의 속성
--커서명이 있는 경우 SQL부분을 커서명으로 넣을 수 있다.
SELECT * INTO V_EMP FROM EMP01 WHERE ROWNUM=1;
DBMS_OUTPUT.PUT_LINE(SQL%ROWCOUNT); END;
/


DECLARE VDEPT DEPT%ROWTYPE; CURSOR C2 IS SELECT * FROM DEPT;
BEGIN DBMS_OUTPUT.PUT_LINE('부서번호/부서명/지역명');
DBMS_OUTPUT.PUT_LINE('-------------------------------');
OPEN C2;
LOOP FETCH C2 INTO VDEPT.DEPTNO,VDEPT.DNAME,VDEPT.LOC;
--IF C2%NOTFOUND THEN DBMS_OUTPUT.PUT_LINE('패치데이터가 없습니다.');
--EXIT; ESLE DBMS_OUTPUT.PUT_LINE('패치데이터가 있습니다.'); END IF;
EXIT WHEN C2%NOTFOUND; --더이상 읽어들일 FETCH가 없으면
DBMS_OUTPUT.PUT_LINE(VDEPT.DEPTNO||' '||VDEPT.DNAME||' '||VDEPT.LOC); END LOOP;
DBMS_OUTPUT.PUT_LINE('행수 => '||C2%ROWCOUNT); CLOSE C2; END;
/


DECLARE V_EMPNO EMP.EMPNO%TYPE; V_ENAME EMP.ENAME%TYPE;
CURSOR CUR_EMP(P_DEPTNO EMP.DEPTNO%TYPE) IS
SELECT EMPNO,ENAME FROM EMP WHERE DEPTNO=P_DEPTNO;
BEGIN OPEN CUR_EMP(30);
LOOP --커서에 선언된 컬럼의 개수,순서,자료형과
--      FETCH~INTO절 안에 선언된 변수의 개수,순서,자료형이 일치해야한다.
FETCH CUR_EMP INTO V_EMPNO,V_ENAME;
EXIT WHEN CUR_EMP%NOTFOUND;
DBMS_OUTPUT.PUT_LINE(V_EMPNO||' '||V_ENAME); END LOOP; CLOSE CUR_EMP; END;
/


DECLARE VDEPT DEPT%ROWTYPE; --생략가능
CURSOR C2 IS SELECT * FROM DEPT;
BEGIN DBMS_OUTPUT.PUT_LINE('부서번호/부서명/지역명');
DBMS_OUTPUT.PUT_LINE('--------------------------------');

FOR VDEPT IN C2 LOOP
--EXIT WHEN C2%NOTFOUND; 생략가능
DBMS_OUTPUT.PUT_LINE(VDEPT.DEPTNO||' '||VDEPT.DNAME||' '||
VDEPT.LOC); END LOOP; END;
/


DECLARE CURSOR CUR_EMP(P_DEPTNO EMP.DEPTNO%TYPE) IS
SELECT * FROM EMP WHERE DEPTNO=P_DEPTNO;
BEGIN FOR EMP_ROW IN CUR_EMP(30)
--LOOP DBMS_OUTPUT.PUT_LINE(EMP_ROW.EMPNO||' '||EMP_ROW.ENAME); END LOOP; END;
LOOP DBMS_OUTPUT.PUT_LINE(EMP_ROW.ENAME||' '||EMP_ROW.EMPNO); END LOOP; END;
/

BEGIN FOR EMP_ROW IN(SELECT * FROM EMP WHERE DEPTNO=30 ORDER BY ENAME)
LOOP DBMS_OUTPUT.PUT_LINE(EMP_ROW.EMPNO||' '||EMP_ROW.ENAME); END LOOP; END;
/


SELECT SAL FROM EMP WHERE DEPTNO=30;
SELECT * FROM EMP WHERE DEPTNO=30;


DECLARE VEMPNO EMP.EMPNO%TYPE; VENAME EMP.ENAME%TYPE;
VJOB EMP.JOB%TYPE; V_SQL VARCHAR2(1000); V_SQL_ENAME EMP.ENAME%TYPE;
BEGIN 
V_SQL:='SELECT EMPNO,ENAME,JOB FROM EMP WHERE ENAME=:A';
/* SQL쿼리문을 변수에 담는다. V_SQL변수가 VARCHAR이므로
안의 SMITH가 문자열이라는 것을 인식하도록 하기 위해서는 ''값''을 사용해야한다.*/
V_SQL_ENAME:='SMITH';
EXECUTE IMMEDIATE V_SQL INTO VEMPNO,VENAME,VJOB USING V_SQL_ENAME;
DBMS_OUTPUT.PUT_LINE('EMPNO : '||VEMPNO);
DBMS_OUTPUT.PUT_LINE('ENAME : '||VENAME);
DBMS_OUTPUT.PUT_LINE('JOB : '||VJOB); END;
/

DECLARE VEMPNO EMP.EMPNO%TYPE; VENAME EMP.ENAME%TYPE;
--바인드변수와 값 설정
VJOB EMP.JOB%TYPE:='CLERK'; VDEPTNO EMP.DEPTNO%TYPE:=30;
V_SQL VARCHAR2(1000);
BEGIN
--SQL쿼리문을 바인드 변수로 처리
V_SQL:='SELECT EMPNO,ENAME FROM EMP WHERE JOB=:A AND DEPTNO=:B';
--가능 V_SQL:='SELECT EMPNO,ENAME FROM EMP WHERE JOB=:A AND DEPTNO=:A';

EXECUTE IMMEDIATE V_SQL INTO VEMPNO,VENAME USING VJOB,VDEPTNO;
DBMS_OUTPUT.PUT_LINE('EMPNO : '||VEMPNO);
DBMS_OUTPUT.PUT_LINE('ENAME : '||VENAME); END;
/

DECLARE V_SQL VARCHAR2(1000);
BEGIN V_SQL:='CREATE TABLE MYINFO(IDS NUMBER,NM VARCHAR2(20), DB DATE)';
EXECUTE IMMEDIATE V_SQL; END;
/


DECLARE
--VIDS MYINFO.IDS%TYPE:=1;
--VNM MYINFO.NM%TYPE:='ALBERT';
--VBD MYINFO.BD%TYPE:=TO_DATE('2000-01-01','YYYY-MM-DD');
VIDS MYINFO.IDS%TYPE:=2;
VNM MYINFO.NM%TYPE:='MAX';
VBD MYINFO.BD%TYPE:=TO_DATE('2005-03-05','YYYY-MM-DD');
VSQL VARCHAR2(1000);
BEGIN
VSQL:='INSERT INTO MYINFO VALUES(:A,:A,:A)';
EXECUTE IMMEDIATE VSQL USING VIDS,VNM,VBD; COMMIT; END;
/


DECLARE VIDS MYINFO.IDS%TYPE:=2; VBD MYINFO.BD%TYPE:=TO_DATE('2010-01-01','YYYY-MM-DD');
VSQL VARCHAR2(1000);
BEGIN VSQL:='UPDATE MYINFO SET IDS=:A,BD=:A WHERE IDS=1';
EXECUTE IMMEDIATE VSQL USING VIDS,VBD; END;
/


DECLARE
   VIDS MYINFO.IDS%TYPE := 1 ;
   VNM MYINFO.NM%TYPE := 'ALBERT' ;
   VBD MYINFO.BD%TYPE := TO_DATE('2010-01-01', 'YYYY-MM-DD') ;
    
   VMY MYINFO%ROWTYPE;    
   CURSOR C_MYINFO  IS SELECT * FROM MYINFO;

   VSQL VARCHAR2(1000);
BEGIN
   VSQL := 'UPDATE MYINFO SET BD = :A WHERE IDS = :A';
   EXECUTE IMMEDIATE VSQL USING VBD, VIDS ;
   COMMIT;
    
   SELECT NM, BD INTO VNM, VBD FROM MYINFO WHERE IDS = VIDS;
   DBMS_OUTPUT.PUT_LINE('UPDATE문 실행 후(COMMIT): ' || VNM || ', ' || VBD);
   DBMS_OUTPUT.PUT_LINE('-------------------------------');
    
   VIDS := 2;
   VSQL := 'DELETE FROM MYINFO WHERE IDS = :A ';    
   EXECUTE IMMEDIATE VSQL USING VIDS;
    
   OPEN C_MYINFO;
   LOOP
      FETCH  C_MYINFO  INTO VMY;
      EXIT WHEN C_MYINFO%NOTFOUND; 
      DBMS_OUTPUT.PUT_LINE('DELETE문 실행 후: ' || VMY.IDS || ' ' || 
      VMY.NM || ' ' || VMY.BD); 
   END LOOP;
   CLOSE C_MYINFO;
   DBMS_OUTPUT.PUT_LINE('-------------------------------');
    
   ROLLBACK;    
   OPEN C_MYINFO;
   LOOP
      FETCH  C_MYINFO  INTO VMY;
      EXIT WHEN C_MYINFO%NOTFOUND;
      DBMS_OUTPUT.PUT_LINE('DELETE문 실행 후: ' || VMY.IDS || ' ' || 
      VMY.NM || ' ' || VMY.BD); 
   END LOOP;
   CLOSE C_MYINFO;
   
END;
/

DECLARE VI_NUM NUMBER:=0;
BEGIN VI_NUM:=10/0; DBMS_OUTPUT.PUT_LINE('Success!'); 
EXCEPTION WHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE('오류가 발생했습니다');
SELECT MOD(5,2) INTO VI_NUM FROM DUAL;
DBMS_OUTPUT.PUT_LINE('VI_NUM : '||VI_NUM);
END;
/

CREATE OR REPLACE PROCEDURE EXCEPTION_PROC IS VI_NUM NUMBER:=0;
BEGIN VI_NUM:=10/0; DBMS_OUTPUT.PUT_LINE('Success!');
EXCEPTION WHEN OTHERS THEN
DBMS_OUTPUT.PUT_LINE('오류가 발생했습니다');
DBMS_OUTPUT.PUT_LINE('SQL ERROR CODE: '||SQLCODE); --매개변수 없는 SQLERRM
DBMS_OUTPUT.PUT_LINE('SQL ERROR MESSAGE: '||SQLERRM); --매개변수 있는 SQLERRM
DBMS_OUTPUT.PUT_LINE(SQLERRM(SQLCODE));
DBMS_OUTPUT.PUT_LINE(DBMS_UTILITY.FORMAT_ERROR_BACKTRACE); END;
/


CREATE OR REPLACE PROCEDURE EXCEPTION_PROC IS VI_NUM NUMBER:=0;
BEGIN VI_NUM:=10/0; DBMS_OUTPUT.PUT_LINE('Success!');
EXCEPTION WHEN ZERO_DIVIDE THEN
DBMS_OUTPUT.PUT_LINE('오류가 발생했습니다');
DBMS_OUTPUT.PUT_LINE('SQL ERROR CODE: '||SQLCODE);
DBMS_OUTPUT.PUT_LINE('SQL ERROR MESSAGE: '||SQLERRM);
END;
/

EXEC EXCEPTION_PROC;

CREATE OR REPLACE PROCEDURE JOB_PROC
(P_EMPLOYEE_ID EMPLOYEES.EMPLOYEE_ID%TYPE,P_JOB_ID JOBS.JOB_ID%TYPE)
IS VN_CNT NUMBER:=0;
BEGIN SELECT COUNT(*) INTO VN_CNT FROM JOBS WHERE JOB_ID=P_JOB_ID;
DBMS_OUTPUT.PUT_LINE(VN_CNT);
UPDATE EMPLOYEES SET JOB_ID=P_JOB_ID WHERE EMPLOYEE_ID=P_EMPLOYEE_ID;
COMMIT;

VN_CNT:=10/0;

EXCEPTION WHEN NO_DATA_FOUND THEN DBMS_OUTPUT.PUT_LINE(SQLERRM);
DBMS_OUTPUT.PUT_LINE(P_JOB_ID||'에 해당하는 JOB_ID가 없습니다.');
WHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE('기타 에러 : '||SQLERRM); END;
/

EXEC JOB_PROC(200,'SM_JOB1');

SELECT ROWNUM RN, C.* FROM
(SELECT * FROM CUSTOMERS WHERE CUST_GENDER='M') C
WHERE ROWNUM<=500;

SAVEPOINT C1;
DELETE FROM DEPT01 WHERE DEPTNO=40;

SAVEPOINT C2;
DELETE FROM DEPT01 WHERE DEPTNO=30;

SELECT * FROM DEPT01;

SAVEPOINT C3;
DELETE FROM DEPT01 WHERE DEPTNO=20;

SELECT * FROM DEPT01;

SAVEPOINT C4;
DELETE FROM DEPT01 WHERE DEPTNO=10;
ROLLBACK TO C2;
SELECT * FROM DEPT01;

ROLLBACK TO C3;
SELECT * FROM DEPT01;

ROLLBACK;
SELECT * FROM DEPT01;